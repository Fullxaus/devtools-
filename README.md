## Результаты само-ревью DVT-9

### Найденные проблемы

#### 1. Отсутствие CI badge в README
**Файл:** README.md (начало файла)
**Проблема:** Нет бейджа статуса сборки GitHub Actions
**Почему важно:** CI badge показывает статус проекта сразу при открытии README —
это стандарт для open-source проектов и упрощает мониторинг состояния сборки.
**Исправление:** Добавить бейдж в начало README:

#### 2. Забыт отладочный вывод
**Файл:** src/main/java/ru/mentee/power/devtools/Demo.java (строка 12)
**Проблема:** Оставлен `System.out.println("Debug: starting loop")`
**Почему важно:** Отладочный вывод замусоривает логи production-приложения и создаёт впечатление небрежности.
**Исправление:** Удалить строку или заменить на logger (если логирование настроено).

#### 3. Закомментированный код
**Файл:** src/main/java/ru/mentee/power/devtools/ProgressLoop.java (строки 23-27)
**Проблема:** Закомментированы 5 строк старой реализации цикла
**Почему важно:** Закомментированный код создаёт путаницу: непонятно зачем он сохранён и актуален ли.
Если нужна история изменений — она в Git.
**Исправление:** Удалить закомментированный код. Если нужна старая версия — посмотреть в Git History.
----------------------------------------------------------------------------------------------------------------


## Информационный поиск — результаты DVT-11

### Запросы и источники

| № | Запрос | Операторы | Официальный источник | Альтернатива | Статус | Дата проверки |
|---|--------|-----------|----------------------|--------------|--------|---------------|
| 1 |Lombok Gradle Short |  https://projectlombok.org/setup/gradle|https://mvnrepository.com/artifact/io.freefair.gradle/lombok-plugin/8.0.0 | 350к   | 9.12.2025     
| 2 | Java Stream API документация|https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Stream.html |https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Stream.html | 280к   | 9.12.2025     |
| 3 |горячие клавиши IntelliJ IDEA |https://www.jetbrains.com/help/idea/mastering-keyboard-shortcuts.html |https://otus.ru/nest/post/494/   | 420к          |9.12.2025


### AI-промпты и сравнение ассистентов

Задача: Нужно добавить валидацию email в класс Student
Контекст: Java 25, у меня есть класс Student с полем email (String), проект на Gradle
Ограничения: без использования регулярных выражений на данном этапе, простая проверка наличия @ и точки
Ожидаемый результат: план из 3-5 шагов, объяснение "почему именно так", НЕ пиши код — я реализую сам
Критерии успеха: валидация отклоняет пустые строки, строки без @, строки без точки после @

AI-1 (ChatGPT):

    Проверьте, что строка не пуста.
    Найдите индекс символа '@' в строке.
    Проверьте, что индекс '@' не равен 0 и что после '@' есть точка.

AI-2 (DeepSeek):

    Проверьте, что строка не пуста и содержит '@'.
    Разделите строку на части по '@' и проверьте, что частей ровно 2.
    Проверьте, что вторая часть содержит точку.

#### Промпт 2: Проверка кода

Промпт 2: Проверка кода

Код для проверки:

public String calculateTotalProgress(Mentee[] mentees) {
// Проверка валидности массива
if (mentees == null || mentees.length == 0) {
return "Суммарно: пройдено 0 из 0 уроков, осталось 0 уроков";
}

        // Инициализация аккумуляторов
        int totalCompleted = 0;
        int totalTotal = 0;
        int index = 0;

        // Цикл while для перебора массива
        while (index < mentees.length) {
            totalCompleted += mentees[index].completedLessons();
            totalTotal += mentees[index].totalLessons();
            index++;
        }

        // Вычисление оставшихся уроков
        int totalRemaining = totalTotal - totalCompleted;

        // Возвращение строки с информацией о суммарном прогрессе
        return String.format("Суммарно: пройдено %d из %d уроков, осталось %d уроков", totalCompleted, totalTotal, totalRemaining);
    }

Что проверить:

    Логические ошибки
    Соответствие Code Conventions
    Производительность

AI-1 (Scout):

Анализ

Логические ошибки:

    Не обрабатывается случай, когда mentees содержит null элементы. При вызове mentees[index].completedLessons() или mentees[index].totalLessons() может возникнуть NullPointerException.
    Не проверяется, что totalTotal не меньше totalCompleted. Если это не так, totalRemaining может быть отрицательным.

Соответствие Code Conventions:

    Название метода calculateTotalProgress корректно.
    Переменные totalCompleted, totalTotal, index имеют понятные имена.
    Однако, вместо использования цикла while, можно использовать более идиоматический для Java цикл for.

Производительность:

    Использование цикла while вместо for не критично для производительности, но менее читаемо.

Улучшение кода :

public String calculateTotalProgress(Mentee[] mentees) {
if (mentees == null || mentees.length == 0) {
return "Суммарно: пройдено 0 из 0 уроков, осталось 0 уроков";
}

    int totalCompleted = 0;
    int totalTotal = 0;

    for (Mentee mentee : mentees) {
        if (mentee != null) {
            totalCompleted += mentee.completedLessons();
            totalTotal += mentee.totalLessons();
        }
    }

    int totalRemaining = Math.max(totalTotal - totalCompleted, 0);

    return String.format("Суммарно: пройдено %d из %d уроков, осталось %d уроков", totalCompleted, totalTotal, totalRemaining);
}

AI-2 (Giga chat):

Логические ошибки

Код выглядит правильным с точки зрения базовой логики, однако есть пара моментов, которые стоит учесть:

    Если массив менторов (Mentee) пуст или равен null, вы возвращаете строку "Суммарно: пройдено 0 из 0 уроков, осталось 0 уроков". Это нормально, но возможно стоит подумать над альтернативным сообщением, например: "Нет учеников." или сделать возврат пустого значения, если такая ситуация критична для бизнес-логики.Однако этот выбор зависит от контекста вашего приложения.
    Ваш цикл использует индексный доступ к элементам массива, что совершенно нормально. Но обратите внимание, что современные Java-стили рекомендуют использование цикла for-each или Stream API там, где это уместно и улучшает читаемость кода.

Code Conventions
1. Структура метода:

   Метод объявлен публичным (public), что верно, если он предназначен для внешнего использования. Однако подумайте, насколько нужен именно открытый метод или же разумнее сделать его защищённым (protected) или закрытым (private), если логика предназначена исключительно для внутреннего использования внутри класса.

2. Форматирование:

   Между методами и переменными рекомендуется оставлять одну пустую строку для лучшей визуальной организации кода.
   Блок проверки ввода (if (mentees == null ...)) лучше расположить перед инициализацией всех остальных переменных, чтобы избежать ненужных вычислений, если условие изначально неверно.

3. Нейминг:

   Название метода calculateTotalProgress() вполне соответствует конвенциям именования методов в Java, но оно длинное. Можно рассмотреть сокращение до более лаконичного названия вроде summarizeProgress().
   Переменная index названа правильно, но её объявление можно переместить непосредственно внутрь цикла, что является хорошим стилем современного Java-кода.

Производительность

Производительности тут почти нечего улучшать, так как ваш алгоритм имеет сложность O(n). Вот несколько мелких улучшений:

    Использование цикла for-each сделает код немного чище и избавит вас от ручной манипуляции с индексом:



for (Mentee mentee : mentees) {
totalCompleted += mentee.completedLessons();
totalTotal += mentee.totalLessons();
}

Это изменение незначительно повлияет на производительность, но улучшит читаемость кода.

    Хотя использование строкового формата (String.format(...)) приемлемо, создание строки вручную с использованием конкатенации тоже хороший вариант, особенно если оптимизировать ресурсоемкость:



return "Суммарно: пройдено " + totalCompleted +
" из " + totalTotal + " уроков, осталось " + totalRemaining + " уроков";

Однако, учитывая современный подход к работе со строками в Java, разницы в производительности практически не будет.

Итоговая версия кода:

Вот как может выглядеть обновленный метод с учётом рекомендаций:


public String summarizeProgress(Mentee[] mentees) {
if (mentees == null || mentees.length == 0) {
return "Нет учеников.";
}

    int totalCompleted = 0;
    int totalTotal = 0;

    for (Mentee mentee : mentees) {
        totalCompleted += mentee.completedLessons();
        totalTotal += mentee.totalLessons();
    }

    int totalRemaining = totalTotal - totalCompleted;

    return String.format("Суммарно: пройдено %d из %d уроков, осталось %d уроков",
                         totalCompleted, totalTotal, totalRemaining);
}

Сравнение:
Scout и Giga chat обнаружили логические ошибки и соответствие Code Conventions. 
Оба ИИ предложили свой вариант по улучшению кода.
---------------------------------------------------------------------------------------------------------------------------------------------

Базовые инструменты разработки
Термин	Определение
JDK (Java Development Kit)	Набор инструментов для разработки на Java, включающий компилятор (javac), библиотеки и JRE. Текущая стабильная версия - JDK 21 LTS.
javac	Компилятор Java, преобразующий исходный код (.java) в байт-код (.class).
java	Команда для запуска Java-приложений, являющаяся частью JRE.
PATH	Системная переменная, содержащая пути к исполняемым файлам. Используется для запуска команд без указания полного пути.
JAVA_HOME	Системная переменная, указывающая на директорию с установленной JDK. Используется другими инструментами для поиска Java.
Интегрированные среды разработки (IDE)
Термин	Определение
IDE (Integrated Development Environment)	Интегрированная среда разработки — программа для написания кода, с функциями редактирования, компиляции, отладки и рефакторинга.
IntelliJ IDEA	Популярная IDE для Java-разработки от JetBrains. Имеет две версии: Community (бесплатная) и Ultimate (платная с расширенными возможностями).
Project Structure	Окно в IntelliJ IDEA для настройки структуры проекта, управления зависимостями и модулями, а также настройки JDK.
Refactoring	Изменение структуры кода без изменения его функциональности. IntelliJ IDEA предоставляет мощные инструменты для рефакторинга.
Live Templates	Шаблоны кода в IDEA, позволяющие быстро вставлять часто используемые конструкции с помощью аббревиатур.
Plugins	Расширения для IDE, добавляющие дополнительную функциональность. Например, плагины для интеграции с Git, поддержки различных фреймворков и инструментов.
Системы контроля версий
Термин	Определение
VCS (Version Control System)	Система контроля версий — инструмент для отслеживания изменений в файлах проекта и координации работы нескольких разработчиков.
Git	Распределённая система контроля версий, созданная Линусом Торвальдсом. Позволяет отслеживать изменения в коде, работать с ветками и объединять изменения от разных разработчиков.
Repository (Репозиторий)	Хранилище кода и истории изменений в Git. Может быть локальным (на компьютере разработчика) и удалённым (на сервере).
Clone	Операция создания локальной копии удалённого репозитория на компьютере разработчика.
Commit	Фиксация изменений в локальном репозитории с добавлением сообщения, описывающего внесённые изменения.
Push	Отправка локальных коммитов в удалённый репозиторий.
Pull	Получение изменений из удалённого репозитория и объединение их с локальной версией.
Branch (Ветка)	Независимая линия разработки в Git, позволяющая работать над новым функционалом или исправлениями без влияния на основной код.
Merge	Объединение изменений из одной ветки в другую.
Pull Request (PR)	Запрос на включение изменений из одной ветки в другую с возможностью код-ревью и обсуждения изменений. В GitHub также называется Merge Request.
GitHub	Популярный веб-сервис для хранения Git-репозиториев и совместной разработки.
.gitignore	Файл, указывающий Git, какие файлы и директории не нужно отслеживать и включать в репозиторий.
Системы сборки и управления зависимостями
Термин	Определение
Build Tool (Инструмент сборки)	Программа, автоматизирующая процесс создания исполняемого приложения из исходного кода.
Gradle	Современный инструмент сборки для Java, использующий язык Groovy или Kotlin для конфигурации. Отличается гибкостью и производительностью.
Maven	Популярный инструмент сборки для Java, использующий XML для конфигурации (pom.xml). Использует соглашения вместо конфигурации.
build.gradle	Основной файл настройки Gradle-проекта, содержащий информацию о зависимостях, задачах и плагинах.
Dependency (Зависимость)	Библиотека или фреймворк, необходимые для работы приложения. Gradle и Maven автоматически скачивают зависимости из репозиториев.
Repository (Репозиторий зависимостей)	Хранилище библиотек и фреймворков, откуда инструменты сборки загружают зависимости. Пример: Maven Central, Google's Maven Repository.
Fat JAR	JAR-файл, содержащий не только скомпилированный код приложения, но и все его зависимости. Позволяет запускать приложение без установки дополнительных библиотек.
Gradle Wrapper	Скрипт, позволяющий запускать Gradle-проект без установки Gradle на компьютер.
Task (Задача)	Единица работы в Gradle, выполняющая определённое действие. Например, компиляция, тестирование, создание JAR-файла.
Plugin (Плагин)	Расширение для Gradle или Maven, добавляющее специфичную функциональность. Например, плагин для Java, для Spring Boot и т.д.
Непрерывная интеграция и доставка (CI/CD)
Термин	Определение
CI/CD (Continuous Integration/Continuous Delivery)	Набор практик, автоматизирующих процессы сборки, тестирования и развертывания приложений.
GitHub Actions	Инструмент CI/CD, встроенный в GitHub. Позволяет автоматизировать различные задачи: сборку, тестирование, деплой и другие.
Workflow	Настраиваемый автоматизированный процесс в GitHub Actions, описываемый в YAML-файле (.github/workflows/).
Runner	Сервер, на котором выполняются задачи CI/CD. Может быть предоставлен GitHub или самостоятельно настроен.
Action	Основной строительный блок в GitHub Actions, выполняющий определённую задачу. Действия могут быть как встроенными, так и сторонними.
Artifact	Результат выполнения Workflow, который можно сохранить и использовать в дальнейшем. Например, JAR-файл или отчёт о тестировании.
Тестирование и TDD
Термин	Определение
JUnit	Фреймворк для модульного (unit) тестирования в Java.
TDD (Test-Driven Development)	Методология разработки ПО, при которой сначала пишутся тесты, а потом код, реализующий необходимую функциональность.
AssertJ	Библиотека для написания более читаемых и выразительных проверок (assertions) в тестах.
Unit Test	Тест, проверяющий небольшую, изолированную часть кода (обычно один метод или класс).
Integration Test	Тест, проверяющий взаимодействие нескольких компонентов системы.
Test Coverage	Мера того, какая часть кода покрыта тестами. Измеряется в процентах от общего количества строк, методов или ветвлений.
Mock	Объект, имитирующий поведение реального объекта в контролируемой среде. Используется для изоляции тестируемого кода.
Инструменты поиска и AI-ассистенты
Термин	Определение
Search Operators	Специальные команды в поисковых системах, позволяющие уточнить запрос. Например, site:, filetype:, - (исключение).
Stack Overflow	Популярный сайт вопросов и ответов для программистов. Часто содержит решения типичных проблем в разработке.
GitHub Search	Инструмент для поиска кода, репозиториев и файлов на GitHub с использованием специального синтаксиса.
AI-инструменты	Программы, использующие искусственный интеллект для помощи в разработке.
AI-ассистент	Программа, использующая машинное обучение для помощи в написании кода, отладке и поиске информации.
Cursor AI	IDE с встроенным AI-ассистентом, специально разработанная для повышения продуктивности программистов.
ChatGPT	AI-модель компании OpenAI для генерации текста и кода на основе запросов пользователя.
YandexGPT	Российский AI-ассистент от Яндекса, способный генерировать код и отвечать на вопросы по программированию.
DeepSeek	AI-модель для генерации кода, оптимизированная специально для задач программирования.
Prompt	Запрос к AI-ассистенту, содержащий описание задачи или вопрос. Качество промпта напрямую влияет на качество ответа.
Код-ревью и лучшие практики
Термин	Определение
Code Review	Процесс проверки кода другими разработчиками для обнаружения ошибок, улучшения качества кода и обмена знаниями.
Google Code Review	Практики код-ревью, разработанные в Google. Включают принципы, процессы и инструменты для эффективного код-ревью.
Static Code Analysis	Автоматический анализ кода без его запуска для обнаружения потенциальных проблем, стилистических ошибок и уязвимостей.
Technical Debt	Накопление проблем в коде из-за выбора быстрых, но не оптимальных решений, которые потребуют дополнительной работы в будущем.
Clean Code	Принципы написания понятного, читаемого и поддерживаемого кода, сформулированные Робертом Мартином.
Refactoring	Изменение внутренней структуры кода без изменения его внешнего поведения с целью улучшения читаемости и поддерживаемости.
DRY (Don't Repeat Yourself)	Принцип разработки ПО, направленный на уменьшение повторений кода и информации.
SOLID	Набор принципов объектно-ориентированного программирования: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion.
Code Style	Набор соглашений о форматировании и структурировании кода, принятый в проекте или команде.
Коммуникация и документация
Термин	Определение
README.md	Основной документационный файл проекта, написанный в формате Markdown. Содержит описание проекта, инструкции по установке и использованию.
Markdown	Лёгкий язык разметки, используемый для форматирования текста в README, документации и комментариях в GitHub.
JavaDoc	Стандарт документирования Java-кода. Генерирует HTML-страницы с описанием классов и методов на основе специальных комментариев в коде.
Issue	Запись о проблеме, задаче или улучшении в системе отслеживания задач (например, GitHub Issues).
Commit Message	Сообщение, описывающее изменения, внесённые в коммите. Хорошее сообщение должно быть понятным и информативным.
Pull Request Description	Описание изменений в Pull Request, объясняющее, что было сделано, почему и как это тестировалось.
